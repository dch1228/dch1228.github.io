---
title: 分布式事务
date: 2021-09-01 16:57:57
tags:
  - 微服务
  - 分布式事务
---

# 使用场景

## 转账

支付宝账户表：A(id, user_id, amount)
余额宝账户表：B(id, user_id, amount)

user_id = 1 的用户，从支付宝转账 1 万元到余额宝分为两个步骤：

1. 支付宝账户表扣款 1 万元
2. 余额宝账户表增加 1 万元

在 MySQL 中，可以通过事务保证一致性

```mysql
begin;
update A set amount=amount-10000 where user_id=1;
update B set amount=amount+10000 where user_id=1;
commit;
```

随着系统变大，我们进行了微服务的改造，每个微服务独占一个数据库。这时转账动作跨越了两个微服务：pay 和 balance。如何保证跨服务的事物一致性？

# 解决方案

## 事务消息

首先系统应该保证每个服务自身的 ACID，基于此，我们可以通过事务消息来保证一致性。

在扣款的同时创建一条消息，消息里记录“让 user_id=1 的余额宝账户增加 1 万元”。

事务消息一旦被可靠的持久化，我们整个分布式事务，变为了最终一致性，消息的消费才能保障最终业务数据的完整性，所以我们要尽最大努力，把消息送达到下游的业务消费方，称为：Best Effort。只有消息被消费，整个交易才能算是完整完结。

## Best Effort

即尽最大努力交付，主要用于在这样一种场景：不同的服务平台之间的事务性保证。

比如我们在电商购物，使用支付宝支付；又比如玩网游的时候，通过 App Store 充值。

拿购物为例，电商平台与支付平台是相互独立的，隶属于不同的公司，即使是同一个公司也很可能是独立的部门。

我们一般会在支付宝的回调页面和接口里，解密参数，然后调用系统中更新交易状态相关的服务，将订单更新为付款成功。

同时，只有当我们回调页面中输出了 success 字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。

## Transactional outbox

## Polling publisher

## Transaction log tailing

## 幂等

## 2PC

## 2PC Message Queue

## Seata 2PC

## TCC